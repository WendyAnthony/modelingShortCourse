---
title: "Calculating Indices and Extracting Values to Points in Google Earth Engine"
author: "Dan Carver,Kaitlin Walker"
date: "April 30, 2018"
output:
  html_document:
    highlight: tango
    number_sections: yes
    theme: journal
    toc: yes
  pdf_document:
    toc: yes
---


# Google Earth Engine as a Single-Workflow Tool

In this excercise, we will walk through an example workflow for calculating indices based on satellite imagery for use in modelling. Then, we'll discuss how to extract these indices to points, all in Google Earth Engine.

Google Earth Engine (GEE) can be a powerful and efficient tool for working with remotely sensed imagery. It can run workflows that otherwise may require multiple platforms to run. Downloading large imagery datasets, transferring rasters to other platforms, and reformatting data can be tedious and  slow down processing time. In GEE, many tasks can be done in a single workflow, without ever having to download your imagery dataset. Although GEE requires code written in Javascript, don't be intimidated! It's simpler that you may think.


# Calculating Vegetation and Spectral Indices
The processes below are just meant to be examples. Don't be limited by what's presented here. If you can builld the indicies in your remote sensing software you can build it in GEE.

## Importing Satellite Data

General tutorials for using Javascript in GEE can be found [here](https://developers.google.com/earth-engine/tutorial_js_01) . However, this tutorial will cover a workflow that you can copy-paste into your code editor and explore right away.

GEE allows you to easily search for and download almost any satellite dataset using the Search Bar. Let's pull in a dataset now. Type **"USGS Landsat 8 Surface Reflectance Tier 1"** into the Search Bar, and click on the result.

A window should appear with information on the dataset. It's a good idea to read through it before using a dataset for analysis.  
![An Image Collection.](ImageCollectionInfo.jpg)  

Notice on the right side of the window, there is an "Import" button. Click this button to import the dataset. Notice that it now appears at the top of your scripting window. Click on the variable name (in purple) to type in a more specific name. For this example, we will use the name **"LS8_SR"**.  
![Imports.](Imports.jpg)

It's interesting to note that you have imported the entire imagery data collection, which consists of all imagery collected over the given time frame and the given area for that sensor. For analysis, you can specify specific images or a region of interest you would like to use. We'll get to this in a bit.

```javascript
var LS8_SR = ee.ImageCollection(LS8_SR).mosaic()
```

We can use a variety of functions to limit our data. In GEE, you can perform multiple functions to a dataset at the same time by just adding them onto the end, separated by a period. First, we will limit our image collection to Landsat Path/Row 28/28 for the 2015-2016 calendar year.We can limit by Path/Row by using the **.filter(ee.Filter.eq())** function, and we can limit by date by using the **.filterDate()** function. Here, we've limited our data to the year of 2015. We would also like imagery with relatively few clouds, so we can also limit it by cloud cover. In this example, we use a cloud cover limit of less than 20 percent. The **.mosaic** function quickly and seamlessly mosaicks an image collection together, which is useful when using mutliple scenes.

Copy-paste this script into the Code Editor, and click the **"Run"** button at the top-right:

```javascript
var LS8_SR1 = ee.ImageCollection(LS8_SR)
  .filterDate('2015-01-01', '2016-01-01')
  .filter(ee.Filter.eq('WRS_PATH', 28))
  .filter(ee.Filter.eq('WRS_ROW', 28))
  .filterMetadata('CLOUD_COVER', 'less_than', 20).mosaic();
```

At the top, we have renamed the Landsat bands to something a little more intuitive. Each is defined as a variable, **"var"**.
Notice that nothing actually happened after you ran this script. In order to see your Image Collection on the map, you must use the **Map.addLayer()** function.

```javascript
Map.addLayer(LS8_SR1)
```

If you'd like to view information on this dataset in the Console, use the **print()** function.
```javascript
print(LS8_SR1,'LS8_SR1')
```
The imported dataset should now be visible in the Console tab, located in the window on the right. Take time to explore the data structure by clicking on the dataset here.  
![Console.](Console.jpg)


## Creating a Region of Interest
We can also limit an Image Collection by defining a region of interest. To do this, we must first create a **Geometry Feature**. In the right corner of the map window, you will see a few buttons symbolized by a hand, a point, a line, and a polygon. Click the polygon button to draw a region of interest. For this excercise, choose an area in Minnesota within Landsat 8 Path/Row 28/28. For example:

![Creating a Region of Interest using Geometry](ROI.jpg)

Now, we see that a geometry import has been added under **Imports**. It is automatically assigned the name "geometry", but let's rename it **"roi."**

We can now limit our Image Collection by this region of interest by redefining the filter bounds by our "roi" geometry. Replace your previous script chunk defining the LS8_SR script with this chunk:
```javascript
var LS8_SR2 = ee.ImageCollection(LS8_SR)
.filterDate('2015-01-01', '2016-01-01')
  .filterBounds(roi)
  .filterMetadata('CLOUD_COVER', 'less_than', 20).mosaic();
Map.addLayer(LS8_SR2)
print(LS8_SR2,'LS8_SR2')
```
If you'd like to comment out bits of code (keep the code in the script but de-activate it), you can add a double-backslash in front of the line(s) you want to comment out. A shortcut for this on Windows is Ctrl+/.

## Defining Indices

In order to define indices, we have to perform some band math. Before we do this, we must first define our individual bands as variables. For this excercise, we'll use bands 1-7, excluding band 6. If we want, we can add on the **.rename** function to rename these bands within the console.

```javascript
var red = LS8_SR2.select('B3').rename("red")
var green= LS8_SR2.select('B2').rename("green")
var blue = LS8_SR2.select('B1').rename("blue")
var nir = LS8_SR2.select('B4').rename("nir")
var swir1 = LS8_SR2.select('B5').rename("swir1")
var swir2 = LS8_SR2.select('B7').rename("swir2")
print(red,'red')
Map.addLayer(red)
print(green, 'green')
Map.addLayer(green)

```
Once you run the above code, print a band variable name and check out this band within the Console. When we expand the drop-down menus, we see that the band is now renamed as we have specified.  
![Renaming a band.](Rename.jpg)


Next, we will define and calculate indices for extraction. We have already defined and renamed a group of bands (bands 1-7, excluding band 6), but we also would like to calculate some vegetation indices.

First, let's use the Normalized Difference Vegetation Index (NDVI). The equation for NDVI is:

**NDVI = (Band 4 - Band 3)/(Band 4 + Band 3)**  
or,  
**NDVI = (nir - red)/(nir + red)**

So, we can do some band math to define an NDVI variable:

```javascript
var ndvi = nir.subtract(red).divide(nir.add(red)).rename('ndvi');

Map.addLayer(ndvi, {},'NDVI',false);
```

Similarly, we can calculate a Tasselled Cap Brightness (TCB) Index:
```javascript
var TCB = LS8_SR.expression(
  "0.2043 * B1 + 0.4158 * B2 + 0.5524 * B3 + 0.5741 * B4 + 0.3124 * B5 + 0.2303 * B7" , {
  'B1': blue,
  'B2': green,
  'B3': red,
  'B4': nir,
  'B5': swir1,
  'B7': swir2
  }).rename("TCB");

Map.addLayer(TCB, {},'TCB',false);
```
The difference between this index example and the previous is that when we use the **.expression** function, we must define the band variables below the expression, instead of embedding them.

Note that we have supposedly added these layers to the map, but they don't show up right away. The "false" argument within **Map.addLayer** tells GEE not to add the layer right away; however, we can still toggle layers on or off using the Layers drop-down, within the map window.

# Extracting Values to Points

## Importing Point Data

In order to extract values to points, you must first import your point dataset, in the form of a Google Fusion Table. Anyone can make a Fusion Table from a CSV as long as you have a google account. These tables also appear in your Google Drive. This short process in outlined in another Tutorial section, titled **"Creating Fusion Tables and Importing Data into Google Earth Engine"**. We recommend you read that first before proceeding.

Now, we can define our point dataset by specifying the ID of our point data fusion table. In this case, we'll use an example fusion table that has been made public for this tutorial. This fusion table is a binary, presence-absence dataset of points collected in Minnesota using high-resolution imagery in GEE. These points indicate areas of wild rice presence and absence, so we have named the variable "PA". However, your data does not have to be binary.

```javascript
var PA_a = ee.FeatureCollection('ft:19YknBH-2mw2tl2ZGN6zDYpFaDx_10LP0lEl5r7Oh')


var PA = PA_a.filterBounds(roi);
Map.addLayer(PA,{},'PA')
print(PA,'PA')

```

Next, we will create a list of our indices, which will serve as modeling predictors. To do this, we start a list of one object (in this case, the NIR band), then add bands to the list, until we have included all of the bands we want to use.
```javascript
var predictors = nir
                            .addBands(blue)
                            .addBands(green)
                            .addBands(red)
                            .addBands(swir1)
                            .addBands(swir2)
                            .addBands(ndvi)
                            .addBands(TCB)


print('predictors: ', predictors);
```

Next, we can extract these points by our list of predictors. To do this we can add on **.sampleRegions** to our list of predictors, which is an image collection. Look up the **ee.Image.sampleRegions()** function under the **Docs** tab to familiarize yourself with its arguments. In summary, the "collection" argument here specifies the data we would like to sample or extract by. The "properties" argument specifies which columns we would like to carry over to the new feature collection we are creating. This will vary based on the column headers of your training point data, so make sure to explore your column headers before-hand. Lastly, the "scale" argument indicates the resolution at which you want to sample.

```javascript
var samples = predictors.sampleRegions({
  collection: PA,
  properties: ['presence'],
  scale: 30 });
print(samples,'samples')

```
## Training the Model
Next, we want to train our model. This is where the **ee.Classifier.randomForest** function comes in. Here, we have a number of parameters specified for each argument, although you may want to experiment with these parameter values yourself. Increasing the number of trees can generally increase accuracy, although this will slow down processing time in GEE, and you may not see much improvement over a certain threshold.


```Javascript
var trainingclassifier = ee.Classifier.randomForest({
                  numberOfTrees: 10,
                  variablesPerSplit: 0,
                  minLeafPopulation: 1 ,
                  bagFraction: 0.5 ,
                  outOfBagMode: false ,
                  seed:7 }).train({
features: samples,
classProperty: 'presence'});
```
Here, the "features" argument of the **.train** function specifies the input feature collection on which to train our model. It is the name of our original training point data, or in this case, our variable called "training".

The "classProperties" argument specifies the property on which to train our model. In this case, it is the response variable, which is either a presence or an absence (a binary response). This is the property we want to predict. This property is called "PA", or the column name of our input point data.

## Apply the Model to Imagery

Now, we have created a classifier, but we have not yet applied it. Lastly, we will create a variable in which to store our outputs from the Random Forest classifier. Here we call it "classified", and use the **ee.FeatureCollection.classify** function to run the classifier we just created, called "trainingclassifier". We apply this to our extracted predictors Image Collection, called "predictors". By adding **.clip**, we can specify a region over which to clip our results. In this case, we have a pre-defined region of interest as a Geometry feature, named "roi".

```javascript
var classified = predictors.classify(trainingclassifier).clip(roi);

print(classified, 'classified')

```
## Viewing the result

Lastly, we can add this model layer to the map, and define a color palette of our choosing.
```javascript
Map.addLayer(classified, {min:0, max:2, palette:['yellow', 'green', 'blue']}, 'classified', false)
```

Finally, export the output as a csv (or an alternate file type, if you prefer) to Google Drive.
```javascript
Export.table.toDrive({
  collection: samples,
  description:'PredictorPoints',
  fileNamePrefix: 'Predictor_Points',
  fileFormat: 'CSV'
});
```

After running all of this, we can go to the **Tasks** tab in the window on the right side of the screen. Normally, it will look like this:
![Inspector, Console, and Tasks.](Tasks.jpg)

After a task is run, or in this case, after we have extracted points and exported them as a CSV, the **Tasks** tab will light up in orange, and we can see the tasks we have just run listed here. Click on the **"Run"** button next to the task we have just added. After the task is finished running, you will have the option to choose an output Google Drive folder in which your outputs will be placed.

You have now created a CSV or KML with all of your extracted point values!
